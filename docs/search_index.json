[["functional-programming.html", "Chapter 5 Automating repeated things 5.1 Flow control 5.2 purrr 5.3 Automote 2 or 2+ tasks 5.4 Automate plotting 5.5 Automate joining 5.6 Make automation slower or faster 5.7 Make error handling easier 5.8 Developing your own data products", " Chapter 5 Automating repeated things Anything that can be automated should be automated. Do as little as possible by hand. Do as much as possible with functions. - Hadley Wickham Setup # Install packages if (!require(&quot;pacman&quot;)) { install.packages(&quot;pacman&quot;) } ## Loading required package: pacman pacman::p_load( tidyverse, # tidyverse pkgs including purrr bench, # performance test tictoc, # performance test broom, # tidy modeling glue, # paste string and objects furrr, # parallel processing rvest, # web scraping devtools, # dev tools usethis, # workflow roxygen2, # documentation testthat, # testing patchwork) # arranging ggplots 5.1 Flow control Control structures = putting logic in code to control flow (e.g., if, else, for, while, repeat, break, next) Almost all the conditional operators used in Python also work in R. The basic loop set up is also very similar, with some small syntax adjustments. if() is a function whose arguments must be specified inside parentheses. else, however, is a reserved operator that takes no arguments. Note that there is no elif option — one simply writes else if(). Whereas operations to be executed after conditional evaluations in Python come after a :, R operations must only be enclosed in curly brackets: {}. Furthermore, there is no requirement for indentation. x &lt;- 5 if (x &lt; 0) { # Condition print(&quot;x is negative&quot;) # Do something } x &lt;- -5 if (x &lt; 0) { print(&quot;x is negative&quot;) } ## [1] &quot;x is negative&quot; x &lt;- 5 if (x &lt; 0) { print(&quot;x is negative&quot;) } else{ print(&quot;x is positive&quot;) } ## [1] &quot;x is positive&quot; x &lt;- 0 if (x &lt; 0) { # Condition print(&quot;x is negative&quot;) # Do something } else if (x == 0) { print(&quot;x is zero&quot;) # Do something else } else {print(&quot;x is positive&quot;) # Do something else } ## [1] &quot;x is zero&quot; R also does some class coercion that makes Boolean evaluations harder to break than in Python. But be careful — R has a set of special coercion used for fast logical evaluation and subsetting. Specifically, TRUE is considered equal to 1, while FALSE is equal to 0. The Boolean logicals can also be specified as a full word in all caps, or simply as T or F. 1 &lt; 2 ## [1] TRUE &quot;1&quot; &lt; 2 ## [1] TRUE &quot;a&quot; &lt; 2 ## [1] FALSE TRUE &lt; 2 ## [1] TRUE TRUE == &quot;TRUE&quot; ## [1] TRUE T == &quot;TRUE&quot; ## [1] TRUE TRUE == &quot;T&quot; ## [1] FALSE TRUE == &quot;FALSE&quot; ## [1] FALSE TRUE == 0 ## [1] FALSE TRUE == 1 ## [1] TRUE FALSE == 0 ## [1] TRUE FALSE &lt;= 1 ## [1] TRUE 5.1.1 Functions While functions are defined in Python using the def reserved operator, R sees functions as just another type of named object. Thus, they require explicit assignment to an object. This is done using the function function(), which creates a function taking the arguments specified in parentheses. function = input + computation (begin -&gt; end) + output simple.function &lt;- function(x){ print(x + 1) } simple.function(x = 2) ## [1] 3 less.simple.function &lt;- function(x, y){ print(x - y + 1) } less.simple.function(x = 2, y = 10) ## [1] -7 With respect to returning function output, most of the same rules apply as with Python. Be sure to remember that return() will only process a single object, so multiple items must usually be returned as a list. Note that your ordering of the functions matters, too. dumbfun &lt;- function(x){ return(x) print(&quot;This will never print :(&quot;) } dumbfun(x = &quot;something&quot;) ## [1] &quot;something&quot; dumbfun &lt;- function(x){ print(&quot;Why did I print?&quot;) return(x) } dumbfun(x = &quot;something&quot;) ## [1] &quot;Why did I print?&quot; ## [1] &quot;something&quot; dumbfun &lt;- function(x,y){ thing1 &lt;- x thing2 &lt;- y return(list(thing1, thing2)) } dumbfun(x = &quot;some text&quot;, y = &quot;some data&quot;) ## [[1]] ## [1] &quot;some text&quot; ## ## [[2]] ## [1] &quot;some data&quot; dumbfun(x = c(5,10,15), y = &quot;some data&quot;) ## [[1]] ## [1] 5 10 15 ## ## [[2]] ## [1] &quot;some data&quot; R functions also allow you to set default argument values: less.simple.function &lt;- function(x, y = 0){ print(x - y + 1) } less.simple.function(x = 2) ## [1] 3 less.simple.function(x = 2, y = 10) ## [1] -7 With respect to specifying arguments, one can either use argument position specifications (i.e., the order) or argument name specifications. The latter is strongly preferred, as it is very easy to accidentally specify incorrect argument values. send &lt;- function(message, recipient, cc=NULL, bcc=NULL){ print(paste(message, recipient, sep = &quot;, &quot;)) print(paste(&quot;CC:&quot;, cc, sep = &quot; &quot;)) print(paste(&quot;BCC:&quot;, bcc, sep = &quot; &quot;)) } send(message = &quot;Hello&quot;, recipient = &quot;World&quot;, cc = &quot;Sun&quot;, bcc = &quot;Jane&quot;) ## [1] &quot;Hello, World&quot; ## [1] &quot;CC: Sun&quot; ## [1] &quot;BCC: Jane&quot; send(&quot;Hello&quot;, &quot;World&quot;, &quot;Sun&quot;, &quot;Jane&quot;) ## [1] &quot;Hello, World&quot; ## [1] &quot;CC: Sun&quot; ## [1] &quot;BCC: Jane&quot; send(&quot;Hello&quot;, &quot;Sun&quot;, &quot;Jane&quot;, &quot;World&quot;) ## [1] &quot;Hello, Sun&quot; ## [1] &quot;CC: Jane&quot; ## [1] &quot;BCC: World&quot; send(message = &quot;Hello&quot;, cc = &quot;Sun&quot;, bcc = c(&quot;Jane&quot;, &quot;Rochelle&quot;), recipient = &quot;World&quot;) ## [1] &quot;Hello, World&quot; ## [1] &quot;CC: Sun&quot; ## [1] &quot;BCC: Jane&quot; &quot;BCC: Rochelle&quot; Also, note that functions don’t have what CS people called side-effects. Functions only define local variables = They don’t change objects stored in the global environment. (Consider the difference between &lt;- and = for assignments.) That’s why you can use functions for reusable tasks since it does not interrupt other important things in your system. See the following example from Wilkinson. a = 1 b = 2 f &lt;- function(x) { a*x + b } f(2) ## [1] 4 g &lt;- function(x) { a = 2 b = 1 f(x) } g(2) # a equals still 1 ## [1] 4 Additional tips Nonstandard evaluation Nonstandard evaluation is an advanced subject. If you feel overwhelmed, you are more than welcome to skip this. But if you are serious in R programming, this is something you want to check out. For deeper understanding of this issue, I recommend reading Ren Kun’s very informative blog post carefully. This part draws on one of the [the dplyr package articles](https://dplyr.tidyverse.org/articles/programming.html. In tidyverse, calling a variable with or without quotation mark (string or not) does make little difference because tidyeval is a type of non-standard evaluation. This flexibility runs into the following problem when it comes to programming. # Using `mpg` instead of `mtcars$mpg` is called data masking. mtcars %&gt;% select(mpg) mtcars %&gt;% select(&quot;mpg&quot;) Data and env-variables # df = environment variable df &lt;- data.frame( x = c(1:5), y = c(6:10) ) # x, y = data variables df$x ## [1] 1 2 3 4 5 df$y ## [1] 6 7 8 9 10 Problem x &lt;- NULL var_summary &lt;- function(env_var, data_var){ env_var %&gt;% summarise(mean = mean(data_var)) } You may expect that the output is mean = 2.5 … but It’s because the mean() function doesn’t take df$x for data_var but x. You need to link x with environment variable var_summary(df, x) ## Warning in mean.default(data_var): argument is not numeric or logical: returning ## NA ## mean ## 1 NA This is how you can fix this. # Solution vs_fix &lt;- function(env_var, data_var){ env_var %&gt;% summarise(mean = mean({{data_var}})) } # You can also do this. vs_fix_enhanced &lt;- function(env_var, data_var){ env_var %&gt;% summarise(&quot;mean_{{data_var}}&quot; := mean({{data_var}})) # If you use the glue package, this syntax is very intuitive. } vs_fix_enhanced(df, x) ## mean_x ## 1 3 If you have a character vector input … mtcars_count &lt;- mtcars %&gt;% names() %&gt;% purrr::map(~count(mtcars, .data[[.x]])) # We&#39;re going to learn about map in the rest of this session. mtcars_count[[1]] ## mpg n ## 1 10.4 2 ## 2 13.3 1 ## 3 14.3 1 ## 4 14.7 1 ## 5 15.0 1 ## 6 15.2 2 ## 7 15.5 1 ## 8 15.8 1 ## 9 16.4 1 ## 10 17.3 1 ## 11 17.8 1 ## 12 18.1 1 ## 13 18.7 1 ## 14 19.2 2 ## 15 19.7 1 ## 16 21.0 2 ## 17 21.4 2 ## 18 21.5 1 ## 19 22.8 2 ## 20 24.4 1 ## 21 26.0 1 ## 22 27.3 1 ## 23 30.4 2 ## 24 32.4 1 ## 25 33.9 1 5.1.2 for loop Loops in R also work basically the same way as in Python, with just a few adjustments. First, recall that index positions in R start at 1. Second, while() and for() are functions rather than reserved operators, meaning they must take arguments in parentheses. Third, just like else, the in operator is reserved and takes no arguments in parentheses. Fourth, the conditional execution must appear between curly brackets. Finally, indentation is meaningless, but each new operation must appear on a new line. while(): when we have no idea how many times loop needs to be executed. for(): when we know how many times loop needs to be executed. This is likely to be the loop you are going to use most frequently. fruits &lt;- c(&quot;apples&quot;, &quot;oranges&quot;, &quot;pears&quot;, &quot;bananas&quot;) # a while loop i &lt;- 1 while (i &lt;= length(fruits)) { print(fruits[i]) i &lt;- i + 1 } ## [1] &quot;apples&quot; ## [1] &quot;oranges&quot; ## [1] &quot;pears&quot; ## [1] &quot;bananas&quot; # a for loop for (i in 1:length(fruits)) { print(fruits[i]) } ## [1] &quot;apples&quot; ## [1] &quot;oranges&quot; ## [1] &quot;pears&quot; ## [1] &quot;bananas&quot; 5.1.3 apply family While and for loops in R can be very slow. For this reason, R has a number of built-in iteration methods to speed up execution times. In many cases, packages will have “behind-the-scenes” ways to avoid for loops, but what if you need to write your own function? A common method of getting around for loops is the apply family of functions. These take a data structure and a function, and applies a function over all the elements in the object. fruit &lt;- c(&quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;banana&quot;) # make function that takes in only one element make.plural &lt;- function(x){ plural &lt;- paste(x, &#39;s&#39;, sep = &#39;&#39;) # sep is for collapse, so collpase &#39;&#39; return(plural) } make.plural(&#39;apple&#39;) ## [1] &quot;apples&quot; apply() : loop over the margins (1 = row, 2 = column) of an array lapply() : loop over a list then returns a list sapply() : loop over a list then returns a named vector tapply(): loop over subsets of a vector mapply(): multivariate version of lapply(). Use this if you have a function that takes in 2 or more arguments. # apply that function to every element lapply(fruit, make.plural) # returns a list ## [[1]] ## [1] &quot;apples&quot; ## ## [[2]] ## [1] &quot;oranges&quot; ## ## [[3]] ## [1] &quot;pears&quot; ## ## [[4]] ## [1] &quot;bananas&quot; sapply(fruit, make.plural) # returns a named vector ## apple orange pear banana ## &quot;apples&quot; &quot;oranges&quot; &quot;pears&quot; &quot;bananas&quot; library(purrr) # load package map(fruit, make.plural) # type consistent ## [[1]] ## [1] &quot;apples&quot; ## ## [[2]] ## [1] &quot;oranges&quot; ## ## [[3]] ## [1] &quot;pears&quot; ## ## [[4]] ## [1] &quot;bananas&quot; # Why sapply is bad sapply(1:100, paste) # return character ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; ## [13] &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; ## [25] &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; ## [37] &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; ## [49] &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; &quot;56&quot; &quot;57&quot; &quot;58&quot; &quot;59&quot; &quot;60&quot; ## [61] &quot;61&quot; &quot;62&quot; &quot;63&quot; &quot;64&quot; &quot;65&quot; &quot;66&quot; &quot;67&quot; &quot;68&quot; &quot;69&quot; &quot;70&quot; &quot;71&quot; &quot;72&quot; ## [73] &quot;73&quot; &quot;74&quot; &quot;75&quot; &quot;76&quot; &quot;77&quot; &quot;78&quot; &quot;79&quot; &quot;80&quot; &quot;81&quot; &quot;82&quot; &quot;83&quot; &quot;84&quot; ## [85] &quot;85&quot; &quot;86&quot; &quot;87&quot; &quot;88&quot; &quot;89&quot; &quot;90&quot; &quot;91&quot; &quot;92&quot; &quot;93&quot; &quot;94&quot; &quot;95&quot; &quot;96&quot; ## [97] &quot;97&quot; &quot;98&quot; &quot;99&quot; &quot;100&quot; sapply(integer(), paste) # return list! ## list() library(purrr) map(1:100, paste) # return list ## [[1]] ## [1] &quot;1&quot; ## ## [[2]] ## [1] &quot;2&quot; ## ## [[3]] ## [1] &quot;3&quot; ## ## [[4]] ## [1] &quot;4&quot; ## ## [[5]] ## [1] &quot;5&quot; ## ## [[6]] ## [1] &quot;6&quot; ## ## [[7]] ## [1] &quot;7&quot; ## ## [[8]] ## [1] &quot;8&quot; ## ## [[9]] ## [1] &quot;9&quot; ## ## [[10]] ## [1] &quot;10&quot; ## ## [[11]] ## [1] &quot;11&quot; ## ## [[12]] ## [1] &quot;12&quot; ## ## [[13]] ## [1] &quot;13&quot; ## ## [[14]] ## [1] &quot;14&quot; ## ## [[15]] ## [1] &quot;15&quot; ## ## [[16]] ## [1] &quot;16&quot; ## ## [[17]] ## [1] &quot;17&quot; ## ## [[18]] ## [1] &quot;18&quot; ## ## [[19]] ## [1] &quot;19&quot; ## ## [[20]] ## [1] &quot;20&quot; ## ## [[21]] ## [1] &quot;21&quot; ## ## [[22]] ## [1] &quot;22&quot; ## ## [[23]] ## [1] &quot;23&quot; ## ## [[24]] ## [1] &quot;24&quot; ## ## [[25]] ## [1] &quot;25&quot; ## ## [[26]] ## [1] &quot;26&quot; ## ## [[27]] ## [1] &quot;27&quot; ## ## [[28]] ## [1] &quot;28&quot; ## ## [[29]] ## [1] &quot;29&quot; ## ## [[30]] ## [1] &quot;30&quot; ## ## [[31]] ## [1] &quot;31&quot; ## ## [[32]] ## [1] &quot;32&quot; ## ## [[33]] ## [1] &quot;33&quot; ## ## [[34]] ## [1] &quot;34&quot; ## ## [[35]] ## [1] &quot;35&quot; ## ## [[36]] ## [1] &quot;36&quot; ## ## [[37]] ## [1] &quot;37&quot; ## ## [[38]] ## [1] &quot;38&quot; ## ## [[39]] ## [1] &quot;39&quot; ## ## [[40]] ## [1] &quot;40&quot; ## ## [[41]] ## [1] &quot;41&quot; ## ## [[42]] ## [1] &quot;42&quot; ## ## [[43]] ## [1] &quot;43&quot; ## ## [[44]] ## [1] &quot;44&quot; ## ## [[45]] ## [1] &quot;45&quot; ## ## [[46]] ## [1] &quot;46&quot; ## ## [[47]] ## [1] &quot;47&quot; ## ## [[48]] ## [1] &quot;48&quot; ## ## [[49]] ## [1] &quot;49&quot; ## ## [[50]] ## [1] &quot;50&quot; ## ## [[51]] ## [1] &quot;51&quot; ## ## [[52]] ## [1] &quot;52&quot; ## ## [[53]] ## [1] &quot;53&quot; ## ## [[54]] ## [1] &quot;54&quot; ## ## [[55]] ## [1] &quot;55&quot; ## ## [[56]] ## [1] &quot;56&quot; ## ## [[57]] ## [1] &quot;57&quot; ## ## [[58]] ## [1] &quot;58&quot; ## ## [[59]] ## [1] &quot;59&quot; ## ## [[60]] ## [1] &quot;60&quot; ## ## [[61]] ## [1] &quot;61&quot; ## ## [[62]] ## [1] &quot;62&quot; ## ## [[63]] ## [1] &quot;63&quot; ## ## [[64]] ## [1] &quot;64&quot; ## ## [[65]] ## [1] &quot;65&quot; ## ## [[66]] ## [1] &quot;66&quot; ## ## [[67]] ## [1] &quot;67&quot; ## ## [[68]] ## [1] &quot;68&quot; ## ## [[69]] ## [1] &quot;69&quot; ## ## [[70]] ## [1] &quot;70&quot; ## ## [[71]] ## [1] &quot;71&quot; ## ## [[72]] ## [1] &quot;72&quot; ## ## [[73]] ## [1] &quot;73&quot; ## ## [[74]] ## [1] &quot;74&quot; ## ## [[75]] ## [1] &quot;75&quot; ## ## [[76]] ## [1] &quot;76&quot; ## ## [[77]] ## [1] &quot;77&quot; ## ## [[78]] ## [1] &quot;78&quot; ## ## [[79]] ## [1] &quot;79&quot; ## ## [[80]] ## [1] &quot;80&quot; ## ## [[81]] ## [1] &quot;81&quot; ## ## [[82]] ## [1] &quot;82&quot; ## ## [[83]] ## [1] &quot;83&quot; ## ## [[84]] ## [1] &quot;84&quot; ## ## [[85]] ## [1] &quot;85&quot; ## ## [[86]] ## [1] &quot;86&quot; ## ## [[87]] ## [1] &quot;87&quot; ## ## [[88]] ## [1] &quot;88&quot; ## ## [[89]] ## [1] &quot;89&quot; ## ## [[90]] ## [1] &quot;90&quot; ## ## [[91]] ## [1] &quot;91&quot; ## ## [[92]] ## [1] &quot;92&quot; ## ## [[93]] ## [1] &quot;93&quot; ## ## [[94]] ## [1] &quot;94&quot; ## ## [[95]] ## [1] &quot;95&quot; ## ## [[96]] ## [1] &quot;96&quot; ## ## [[97]] ## [1] &quot;97&quot; ## ## [[98]] ## [1] &quot;98&quot; ## ## [[99]] ## [1] &quot;99&quot; ## ## [[100]] ## [1] &quot;100&quot; map(integer(), paste) # return list ## list() 5.2 purrr 5.2.1 Why map? 5.2.1.1 Objectives How to use purrr to automate workflow in a cleaner, faster, and more extendable way 5.2.1.2 Copy-and-paste programming Copy-and-paste programming, sometimes referred to as just pasting, is the production of highly repetitive computer programming code, as produced by copy and paste operations. It is primarily a pejorative term; those who use the term are often implying a lack of programming competence. It may also be the result of technology limitations (e.g., an insufficiently expressive development environment) as subroutines or libraries would normally be used instead. However, there are occasions when copy-and-paste programming is considered acceptable or necessary, such as for boilerplate, loop unrolling (when not supported automatically by the compiler), or certain programming idioms, and it is supported by some source code editors in the form of snippets. - Wikipedia The following exercise was inspired by Wickham’s example. Let’s imagine df is a survey dataset. a, b, c, d = Survey questions -99: non-responses Your goal: replace -99 with NA # Data set.seed(1234) # for reproducibility df &lt;- tibble( &quot;a&quot; = sample(c(-99, 1:3), size = 5, replace = TRUE), &quot;b&quot; = sample(c(-99, 1:3), size = 5, replace = TRUE), &quot;c&quot; = sample(c(-99, 1:3), size = 5, replace = TRUE), &quot;d&quot; = sample(c(-99, 1:3), size = 5, replace = TRUE) ) # Copy and paste df$a[df$a == -99] &lt;- NA df$b[df$b == -99] &lt;- NA df$c[df$c == -99] &lt;- NA df$d[df$d == -99] &lt;- NA df ## # A tibble: 5 x 4 ## a b c d ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 3 3 1 ## 2 3 2 3 1 ## 3 1 NA 1 2 ## 4 1 NA 2 1 ## 5 NA 1 1 3 Challenge. Explain why this solution is not very efficient (Hint: If df$a[df$a == -99] &lt;- NA has an error, how are you going to fix it? A solution is not scalable if it’s not automatable. 5.2.1.3 Using a function Let’s recall what’s function in R: input + computation + output If you write a function, you gain efficiency because you don’t need to copy and paste the computation part. ` function(input){ computation return(output) } ` # Function fix_missing &lt;- function(x) { x[x == -99] &lt;- NA x } # Apply function to each column (vector) df$a &lt;- fix_missing(df$a) df$b &lt;- fix_missing(df$b) df$c &lt;- fix_missing(df$c) df$d &lt;- fix_missing(df$d) df ## # A tibble: 5 x 4 ## a b c d ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 3 3 1 ## 2 3 2 3 1 ## 3 1 NA 1 2 ## 4 1 NA 2 1 ## 5 NA 1 1 3 Challenge Why using function is more efficient than 100% copying and pasting? Can you think about a way we can automate the process? Many options for automation in R: for loop, apply family, etc. Here’s a tidy solution comes from purrr package. The power and joy of one-liner. df &lt;- purrr::map_df(df, fix_missing) df ## # A tibble: 5 x 4 ## a b c d ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 3 3 1 ## 2 3 2 3 1 ## 3 1 NA 1 2 ## 4 1 NA 2 1 ## 5 NA 1 1 3 map() is a higher-order function that applies a given function to each element of a list/vector. This is how map() works. It’s easier to understand with a picture. - Input: Takes a vector/list. - Computation: Calls the function once for each element of the vector - Output: Returns in a list or whatever data format you prefer (e.g., `_df helper: dataframe`) Challenge If you run the code below, what’s going to be the data type of the output? map(df, fix_missing) ## $a ## [1] 3 3 1 1 NA ## ## $b ## [1] 3 2 NA NA 1 ## ## $c ## [1] 3 3 1 2 1 ## ## $d ## [1] 1 1 2 1 3 Why map() is a good alternative to for loop. The Joy of Functional Programming (for Data Science) - Hadley Wickham # Built-in data data(&quot;airquality&quot;) tic() # Placeholder out1 &lt;- vector(&quot;double&quot;, ncol(airquality)) # Sequence variable for (i in seq_along(airquality)) { # Assign an iteration result to each element of the placeholder list out1[[i]] &lt;- mean(airquality[[i]], na.rm = TRUE) } toc() ## 0.05 sec elapsed map is faster because it applies function to the items on the list/vector in parallel. Also, using map_dbl reduces an extra step you need to take. Hint: map_dbl(x, mean, na.rm = TRUE) = vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1)) tic() out1 &lt;- airquality %&gt;% map_dbl(mean, na.rm = TRUE) toc() ## 0.016 sec elapsed In short, map() is more readable, faster, and easily extendable with other data science tasks (e.g., wrangling, modeling, and visualization) using %&gt;%. Final point: Why not base R apply family? Short answer: purrr::map() is simpler to write. For instance, Additional tips Performance testing (profiling) is an important part of programming. tictic() measures the time that needs to take to run a target function for once. If you want a more robust measure of timing as well as information on memory (speed and space both matter for performance testing), consider using the bench package that is designed for high precising timing of R expressions. map_mark &lt;- bench::mark( out1 &lt;- airquality %&gt;% map_dbl(mean, na.rm = TRUE) ) map_mark ## # A tibble: 1 x 6 ## expression min median `itr/sec` ## &lt;bch:expr&gt; &lt;bch:&gt; &lt;bch:&gt; &lt;dbl&gt; ## 1 out1 &lt;- airquality %&gt;% map_dbl(mean, na.rm = TRUE) 1.12ms 1.29ms 726. ## # … with 2 more variables: mem_alloc &lt;bch:byt&gt;, `gc/sec` &lt;dbl&gt; 5.2.1.4 Applications Many models One popular application of map() is to run regression models (or whatever model you want to run) on list-columns. No more copying and pasting for running many regression models on subgroups! # Have you ever tried this? lm_A &lt;- lm(y ~ x, subset(data, subgroup == &quot;group_A&quot;)) lm_B &lt;- lm(y ~ x, subset(data, subgroup == &quot;group_B&quot;)) lm_C &lt;- lm(y ~ x, subset(data, subgroup == &quot;group_C&quot;)) lm_D &lt;- lm(y ~ x, subset(data, subgroup == &quot;group_D&quot;)) lm_E &lt;- lm(y ~ x, subset(data, subgroup == &quot;group_E&quot;)) For more information on this technique, read the Many Models subchapter of the R for Data Science. # Function lm_model &lt;- function(df) { lm(Temp ~ Ozone, data = df) } # Map models &lt;- airquality %&gt;% group_by(Month) %&gt;% nest() %&gt;% # Create list-columns mutate(ols = map(data, lm_model)) # Map models$ols[1] ## [[1]] ## ## Call: ## lm(formula = Temp ~ Ozone, data = df) ## ## Coefficients: ## (Intercept) Ozone ## 62.8842 0.1629 # Add tidying tidy_lm_model &lt;- purrr::compose( # compose multiple functions broom::tidy, # convert lm objects into tidy tibbles lm_model ) tidied_models &lt;- airquality %&gt;% group_by(Month) %&gt;% nest() %&gt;% # Create list-columns mutate(ols = map(data, tidy_lm_model)) tidied_models$ols[1] ## [[1]] ## # A tibble: 2 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 62.9 1.61 39.2 2.88e-23 ## 2 Ozone 0.163 0.0500 3.26 3.31e- 3 Simulations A good friend of map() function is rerun() function. This comibination is really useful for simulations. Consider the following example. Base R approach set.seed(1234) small_n &lt;- 100 ; k &lt;- 1000 ; mu &lt;- 500 ; sigma &lt;- 20 y_list &lt;- rep(list(NA), k) for (i in seq(k)) { y_list[[i]] &lt;- rnorm(small_n, mu, sigma) } y_means &lt;- unlist(lapply(y_list, mean)) qplot(y_means) + geom_vline(xintercept = 500, linetype = &quot;dotted&quot;, color = &quot;red&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. rerun() + map() small_n &lt;- 100 ; k &lt;- 1000 y_tidy &lt;- rerun(k, rnorm(small_n, mu, sigma)) y_means_tidy &lt;- map_dbl(y_tidy, mean) # Visualize (qplot(y_means) + geom_vline(xintercept = 500, linetype = &quot;dotted&quot;, color = &quot;red&quot;)) + (qplot(y_means_tidy) + geom_vline(xintercept = 500, linetype = &quot;dotted&quot;, color = &quot;red&quot;)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 5.3 Automote 2 or 2+ tasks 5.3.1 Objectives Learning how to use map2() and pmap() to avoid writing nested loops. 5.3.2 Problem Problem: How can you create something like below? [1] “University = Berkeley | Department = waterbenders” [1] “University = Berkeley | Department = earthbenders” [1] “University = Berkeley | Department = firebenders” [1] “University = Berkeley | Department = airbenders” [1] “University = Stanford | Department = waterbenders” [1] “University = Stanford | Department = earthbenders” [1] “University = Stanford | Department = firebenders” [1] “University = Stanford | Department = airbenders” The most manual way: You can copy and paste eight times. paste(&quot;University = Berkeley | Department = CS&quot;) ## [1] &quot;University = Berkeley | Department = CS&quot; 5.3.3 For loop A slightly more efficient way: using a for loop. Think about which part of the statement is constant and which part varies ( = parameters). Do we need a placeholder? No. We don’t need a placeholder because we don’t store the result of iterations. Challenge: How many parameters do you need to solve the problem below? # Outer loop for (univ in c(&quot;Berkeley&quot;, &quot;Stanford&quot;)) { # Inner loop for (dept in c(&quot;waterbenders&quot;, &quot;earthbenders&quot;, &quot;firebenders&quot;, &quot;airbenders&quot;)) { print(paste(&quot;University = &quot;, univ, &quot;|&quot;, &quot;Department = &quot;, dept)) } } ## [1] &quot;University = Berkeley | Department = waterbenders&quot; ## [1] &quot;University = Berkeley | Department = earthbenders&quot; ## [1] &quot;University = Berkeley | Department = firebenders&quot; ## [1] &quot;University = Berkeley | Department = airbenders&quot; ## [1] &quot;University = Stanford | Department = waterbenders&quot; ## [1] &quot;University = Stanford | Department = earthbenders&quot; ## [1] &quot;University = Stanford | Department = firebenders&quot; ## [1] &quot;University = Stanford | Department = airbenders&quot; This is not bad, but … n arguments -&gt; n-nested for loops. As a scale of your problem grows, your code gets really complicated. To become significantly more reliable, code must become more transparent. In particular, nested conditions and loops must be viewed with great suspicion. Complicated control flows confuse programmers. Messy code often hides bugs. — Bjarne Stroustrup 5.3.4 map2 &amp; pmap Step 1: Define inputs and a function. Challenge Why are we using rep() to create input vectors? For instance, for univ_list why not just use c(\"Berkeley\", \"Stanford\")? # Inputs (remember the length of these inputs should be identical) univ_list &lt;- rep(c(&quot;Berkeley&quot;, &quot;Stanford&quot;), 4) dept_list &lt;- rep(c(&quot;waterbenders&quot;, &quot;earthbenders&quot;, &quot;firebenders&quot;, &quot;airbenders&quot;), 2) # Function print_lists &lt;- function(univ, dept) { print(paste( &quot;University = &quot;, univ, &quot;|&quot;, &quot;Department = &quot;, dept )) } # Test print_lists(univ_list[1], dept_list[1]) ## [1] &quot;University = Berkeley | Department = waterbenders&quot; Step2: Using map2() or pmap() # 2 arguments map2_output &lt;- map2(univ_list, dept_list, print_lists) ## [1] &quot;University = Berkeley | Department = waterbenders&quot; ## [1] &quot;University = Stanford | Department = earthbenders&quot; ## [1] &quot;University = Berkeley | Department = firebenders&quot; ## [1] &quot;University = Stanford | Department = airbenders&quot; ## [1] &quot;University = Berkeley | Department = waterbenders&quot; ## [1] &quot;University = Stanford | Department = earthbenders&quot; ## [1] &quot;University = Berkeley | Department = firebenders&quot; ## [1] &quot;University = Stanford | Department = airbenders&quot; # 3+ arguments pmap_output &lt;- pmap(list(univ_list, dept_list), print_lists) ## [1] &quot;University = Berkeley | Department = waterbenders&quot; ## [1] &quot;University = Stanford | Department = earthbenders&quot; ## [1] &quot;University = Berkeley | Department = firebenders&quot; ## [1] &quot;University = Stanford | Department = airbenders&quot; ## [1] &quot;University = Berkeley | Department = waterbenders&quot; ## [1] &quot;University = Stanford | Department = earthbenders&quot; ## [1] &quot;University = Berkeley | Department = firebenders&quot; ## [1] &quot;University = Stanford | Department = airbenders&quot; Challenge Have you noticed that we used a slightly different input for pmap() compared to map() or map2()? What is the difference? 5.4 Automate plotting 5.4.1 Objective Learning how to use map() and glue() to automate creating multiple plots 5.4.2 Problem Making the following data visualization process more efficient. data(&quot;airquality&quot;) airquality %&gt;% ggplot(aes(x = Ozone, y = Solar.R)) + geom_point() + labs( title = &quot;Relationship between Ozone and Solar.R&quot;, y = &quot;Solar.R&quot; ) ## Warning: Removed 42 rows containing missing values (geom_point). airquality %&gt;% ggplot(aes(x = Ozone, y = Wind)) + geom_point() + labs( title = &quot;Relationship between Ozone and Wind&quot;, y = &quot;Wind&quot; ) ## Warning: Removed 37 rows containing missing values (geom_point). airquality %&gt;% ggplot(aes(x = Ozone, y = Temp)) + geom_point() + labs( title = &quot;Relationship between Ozone and Temp&quot;, y = &quot;Temp&quot; ) ## Warning: Removed 37 rows containing missing values (geom_point). 5.4.3 Solution Learn how glue() works. glue() combines strings and objects and it works simpler and faster than paste() or sprintif(). names &lt;- c(&quot;Jae&quot;, &quot;Aniket&quot;, &quot;Avery&quot;) fields &lt;- c(&quot;Political Science&quot;, &quot;Law&quot;, &quot;Public Health&quot;) glue(&quot;{names} studies {fields}.&quot;) ## Jae studies Political Science. ## Aniket studies Law. ## Avery studies Public Health. So, our next step is to combine glue() and map(). Let’s first think about writing a function that includes glue(). Challenge How can you create the character vector of column names? Challenge How can you make ggplot2() take strings as x and y variable names? (Hint: Type ?aes_string()) airquality %&gt;% ggplot(aes_string(x = names(airquality)[1], y = names(airquality)[2])) + geom_point() + labs( title = glue(&quot;Relationship between Ozone and {names(airquality)[2]}&quot;), y = glue(&quot;{names(airquality)[2]}&quot;) ) ## Warning: Removed 42 rows containing missing values (geom_point). The next step is to write an automatic plotting function. Note that in the function argument i (abstract) replaced 2 (specific): abstraction create_point_plot &lt;- function(i) { airquality %&gt;% ggplot(aes_string(x = names(airquality)[1], y = names(airquality)[i])) + geom_point() + labs( title = glue(&quot;Relationship between Ozone and {names(airquality)[i]}&quot;), y = glue(&quot;{names(airquality)[i]}&quot;) ) } The final step is to put the function in map(). map(2:ncol(airquality), create_point_plot) ## [[1]] ## Warning: Removed 42 rows containing missing values (geom_point). ## ## [[2]] ## Warning: Removed 37 rows containing missing values (geom_point). ## ## [[3]] ## Warning: Removed 37 rows containing missing values (geom_point). ## ## [[4]] ## Warning: Removed 37 rows containing missing values (geom_point). ## ## [[5]] ## Warning: Removed 37 rows containing missing values (geom_point). 5.5 Automate joining 5.5.1 Objective Learning how to use reduce() to automate joining multiple dataframes 5.5.2 Problem How can you make joining multiple dataframes more efficient? Note that we will use dplyr::left_join() = merge(x, y, all.x = TRUE). df1 &lt;- tibble( x = sample(1:10, size = 3, replace = TRUE), y = sample(1:10, size = 3, replace = TRUE), z = sample(1:10, size = 3, replace = TRUE) ) df2 &lt;- tibble( x = sample(1:10, size = 3, replace = TRUE), y = sample(1:10, size = 3, replace = TRUE), z = sample(1:10, size = 3, replace = TRUE) ) df3 &lt;- tibble( x = sample(1:10, size = 3, replace = TRUE), y = sample(1:10, size = 3, replace = TRUE), z = sample(1:10, size = 3, replace = TRUE) ) 5.5.3 Copy and paste first_join &lt;- left_join(df1, df2) ## Joining, by = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) second_join &lt;- left_join(first_join, df3) ## Joining, by = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) second_join ## # A tibble: 3 x 3 ## x y z ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 7 3 7 ## 2 6 1 5 ## 3 2 1 6 Challenge Why the above solution is not efficient? 5.5.4 reduce How reduce() works. - Input: Takes a vector of length n - Computation: Calls a function with a pair of values at a time - Output: Returns a vector of length 1 reduced &lt;- reduce(list(df1, df2, df3), left_join) ## Joining, by = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) ## Joining, by = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) reduced ## # A tibble: 3 x 3 ## x y z ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 7 3 7 ## 2 6 1 5 ## 3 2 1 6 5.6 Make automation slower or faster 5.6.1 Objectives Learning how to use slowly() and future_ to make automation process either slower or faster 5.6.2 How to make automation slower Scraping 50 pages from a website and you don’t want to overload the server. How can you do that? 5.6.3 For loop 5.6.4 Map walk() works same as map() but doesn’t store its output. If you’re web scraping, one problem with this approach is it’s too fast by human standards. If you want to make the function run slowly … slowly() takes a function and modifies it to wait a given amount of time between each call. - purrr package vignette - If a function is a verb, then a helper function is an adverb (modifying the behavior of the verb). 5.6.5 How to make automation Faster In a different situation, you want to make your function run faster. This is a common situation when you collect and analyze data at large-scale. You can solve this problem using parallel processing. For more on the parallel processing in R, read this review. Parallel processing setup Step1: Determine the number of max workers (availableCores()) Step2: Determine the parallel processing mode (plan()) 5.7 Make error handling easier 5.7.1 Learning objective Learning how to use safely() and possibly() to make error handling easier ### Problem Challenge Explain why we can’t run map(url_lists, read_html) url_lists &lt;- c( &quot;https://en.wikipedia.org/wiki/University_of_California,_Berkeley&quot;, &quot;https://en.wikipedia.org/wiki/Stanford_University&quot;, &quot;https://en.wikipedia.org/wiki/Carnegie_Mellon_University&quot;, &quot;https://DLAB&quot; ) map(url_lists, read_html) This is a very simple problem so it’s easy to tell where the problem is. How can you make your error more informative? 5.7.2 Solution 5.7.2.1 Try-catch There are three kinds of messages you will run into, if your code has an error based on the following functions. stop(): errors; Functions must stop. warning(): warnings; Functions may still work. Nonetheless, something is possibly messed up. message(): messages; Some actions happened. The basic logic of try-catch, R’s basic error handling function, works like the following. tryCatch( { map(url_lists, read_html) }, warning = function(w) { &quot;Warning&quot; }, error = function(e) { &quot;Error&quot; }, finally = { &quot;Message&quot; } ) ## [1] &quot;Error&quot; Here’s purrr version of the try-catch mechanism (evaluates code and assigns exception handlers). 5.7.2.2 safely Outputs result: result or NULL error: NULL or error map(url_lists, safely(read_html)) ## [[1]] ## [[1]]$result ## {html_document} ## &lt;html class=&quot;client-nojs&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8 ... ## [2] &lt;body class=&quot;mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject ... ## ## [[1]]$error ## NULL ## ## ## [[2]] ## [[2]]$result ## {html_document} ## &lt;html class=&quot;client-nojs&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8 ... ## [2] &lt;body class=&quot;mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject ... ## ## [[2]]$error ## NULL ## ## ## [[3]] ## [[3]]$result ## {html_document} ## &lt;html class=&quot;client-nojs&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8 ... ## [2] &lt;body class=&quot;mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject ... ## ## [[3]]$error ## NULL ## ## ## [[4]] ## [[4]]$result ## NULL ## ## [[4]]$error ## &lt;simpleError in open.connection(x, &quot;rb&quot;): Could not resolve host: DLAB&gt; The easier way to solve this problem is just avoiding the error. map(url_lists, safely(read_html)) %&gt;% map(&quot;result&quot;) %&gt;% # = map(function(x) x[[&quot;result&quot;]]) = map(~.x[[&quot;name&quot;]]) purrr::compact() # Remove empty elements ## [[1]] ## {html_document} ## &lt;html class=&quot;client-nojs&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8 ... ## [2] &lt;body class=&quot;mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject ... ## ## [[2]] ## {html_document} ## &lt;html class=&quot;client-nojs&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8 ... ## [2] &lt;body class=&quot;mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject ... ## ## [[3]] ## {html_document} ## &lt;html class=&quot;client-nojs&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8 ... ## [2] &lt;body class=&quot;mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject ... 5.7.2.3 possibly What if the best way to solve the problem is not ignoring the error … # If error occurred, &quot;The URL is broken.&quot; will be stored in that element(s). out &lt;- map( url_lists, possibly(read_html, otherwise = &quot;The URL is broken.&quot; ) ) # Let&#39;s find the broken URL. url_lists[out[seq(out)] == &quot;The URL is broken.&quot;] ## [1] &quot;https://DLAB&quot; 5.8 Developing your own data products A data product is the production output from a statistical analysis. - Brian Caffo 5.8.1 Developing R packages Reuse your code Automate your workflow Help others (be part of an open source development community) 5.8.1.1 Workflow Write code in \\R Document code in \\man (automated by roxygen2 package) devtools::document() Check dependencies in NAMESPACE devtools::update() updates the documentation devtools::check() to see whether your package is ready to be submitted to CRAN Build a package (for more information, read this section in Hadley’s R package development book) devtools::build() (Optional) Test (devtools::test()), teach in \\vignettes, and add data in \\data Distribute the package either via CRAN or GitHub It’s time to learn five states of R code: source, bundled, binary, installed, and in-memory. If you’re just using an R package, you’re only concerned of the last two states: install.packages(\"pkg\") and library(pkg) If you’re developing an R package, you first write source code (*.R), bundle it (compressed file like *.tar.gz; done by devtools::build()), then make it binary (devtools::build(binary = TRUE); This is how a package is stored in CRAN/GitHub, etc.). 5.8.1.2 Required Components The 4 required components are necessary to build and distribute a minimally viable R package. The other steps are optional. Package \\R: R functions \\man: function documentations DESCRIPTION: provides meta data about the package (e.g., author) LICENSE GNU, MIT, etc. NAMESPACE: package dependencies (to make your package self-contained) README (optional) Setup (DESCRIPTION) # This function creates DESCRIPTION file usethis::create_package(here(&quot;mypkg&quot;)) # Initialize git repo usethis::use_git() # License the package # You can use the MIT license by typing devtools::use_mit_license(&quot;author name&quot;). The function produces MIT license related files (LICENSE, LICENSE.md). use_mit_license(&quot;Jae Yeon Kim&quot;) # Add README (optional) # Makes the package more use-friendly use_readme_md() # Add news (optional) # Helps track changes use_news_md() Write code (R) usethis::use_r(&quot;rbind_mutate&quot;) #&#39; Add two numbers #&#39; #&#39; @param x A number #&#39; @param y A number #&#39; @return The sum of x and y #&#39; @export add &lt;- function(x, y){ x + y } Document (man) # Document # The function creates documentation related files (NAMESPACE, function_name.rd) devtools::document() # Load all; simulates installing and reloading the package devtools::load_all() # Check; updates the documentation; builds and checks the package devtools::check() devtools::bash() Organize (NAMESPACE) usethis::use_package(&quot;dplyr&quot;) 5.8.1.3 Optional Components Test (test) usethis::use_testthat() usethis::use_test(&quot;rbind_mutate&quot;) Add data (data) x &lt;- &quot;Jae&quot; y &lt;- &quot;Sun&quot; z &lt;- &quot;Jane&quot; usethis::use_data(x, y, z, overwrite = TRUE) Teach (vignetts) usethis::use_vignette(&quot;rbind_mutate&quot;) title: &quot;Vignette title&quot; author: &quot;Vignette author&quot; date: &quot;2020-11-07&quot; output: rmarkdown::html_vignette vignette: blah blah You can build a package website using pkgdown # install.packages(&quot;pkgdown&quot;) usethis::use_pkgdown() pkgdown::build_site() A package site includes information on METADATA, Function references, Articles, News, etc. 5.8.1.4 Building an R package CMD (in the terminal) You can run R commands in the terminal using R CMD. devtools # Build devtools::build() # Install devtools::install() 5.8.1.5 Distributing an R package # Version update usethis::use_version() # Spell check usethis::use_spell_check() CRAN (The Comprehensive R Archive Network) R package submission should comply with the CRAN Repository Policy GitHub Push everything to the Git repository (you can do it using command-line interface or RStudio). Don’t forget that your repository should be public. I highly recommend connecting GitHub with SSH. For more information, visit this link. 5.8.2 Developing Shiny apps Shiny is a “framework for creating web applications using R code”. You can create a dashboard or an interactive map without knowing anything about HTML, CSS, or JavaScript. Developing a shiny app helps people with little technical expertise to learn from your data in an intuitive and interactive way. Shiny in production: Principles, practices, and tools - Joe Cheng COVID-19 tracker by Edward Parker 5.8.2.1 Workflow The workflow follows what Hadley Wickham recommended in his book on mastering shiny. Install libraries install.packages(&quot;shiny&quot;) Create app directory and file Add an app.R file. The key objective here is defining your UI (how the app looks; front-end = INPUT) (defined in object ui) and server (how the app works; back-end = OUTPUT) (defined in object server). If you’re creating a complex app, you can achieve the same goal with two files: ui.R and server.R. 5.8.2.2 app.r Front-end # Load packages # Do not use install.packages(), pacman::p_load(), or library() if you intend to deploy the app using shinyapps.io require(&quot;wordcloud2&quot;) require(&quot;shiny&quot;) require(&quot;shinydashboard&quot;) require(&quot;colourpicker&quot;) # Load data df &lt;- read.csv(url(&quot;https://github.com/jaeyk/covid19antiasian/raw/master/processed_data/hash_counts.csv&quot;))[,-1] # Defines the user interface; how the app looks ui &lt;- fluidPage( # Application title titlePanel(&quot;Word Cloud on the Hashtags of the Tweets related to COVID-19 &amp; Asian|Chinese|Wuhan&quot;), h4(tags$a(href = &quot;https://jaeyk.github.io/&quot;, &quot;Developer: Jae Yeon Kim&quot;)), sidebarLayout( # Sidebar with sliders sidebarPanel( sliderInput(&quot;size&quot;, &quot;Font size:&quot;, min = 1, max = 10, value = 2) ), mainPanel( wordcloud2Output(&quot;cloud&quot;), ) ) ) Back-end server &lt;- function(input, output, session) { output$cloud &lt;- renderWordcloud2({ wordcloud2(df, size = input$size, color = &quot;random-dark&quot;) }) } Build a shiny app shinyApp(ui = ui, server = server) 5.8.2.3 Deployment Deploy to the shinyapps.io cloud # Install packages install.packages(&quot;rsconnect&quot;) library(rsconnect) # Setup rsconnect::setAccountInfo(name = &quot;&lt;Account name&gt;&quot;, token = &quot;&lt;Token&gt;&quot;, secret = &quot;&lt;Secret&gt;&quot;) rsconnect::deployApp(appNames = &quot;&lt;App name&gt;&quot;) 5.8.2.4 References Mastering Shiny by Hadley Wickham. For newbies. Shiny Documents by Yihui Xie Engineering Production-Grade Shiny Apps by Colin Fay, Sébastien Rochette, Vincent Guyader, Cervan Girard. For experienced developers. Building Shiny Apps by Dean Attali. 5.8.3 Other useful data products Automating data reports using rmarkdown (called parameterized reports) Automating R presentation using slidify Creating interactive web apps using leaflet "]]
